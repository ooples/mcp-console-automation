import { EventEmitter } from 'events';
import { Client as SSHClient, ClientChannel, ConnectConfig } from 'ssh2';
import { readFileSync } from 'fs';
import { v4 as uuidv4 } from 'uuid';
import stripAnsi from 'strip-ansi';
import { IProtocol, ProtocolCapabilities, ProtocolHealthStatus } from '../core/ProtocolFactory.js';
import {
  ConsoleSession,
  ConsoleOutput,
  SessionOptions,
  SSHConnectionOptions,
  PooledConnection,
  QueuedCommand,
  SessionCommandQueue,
  CommandQueueConfig,
  ConnectionHealth,
  ExtendedErrorPattern
} from '../types/index.js';
import { Logger } from '../utils/logger.js';
import { StreamManager } from '../core/StreamManager.js';
import { SSHConnectionKeepAlive, KeepAliveConfig } from '../core/SSHConnectionKeepAlive.js';
import { PromptDetector, PromptDetectionResult } from '../core/PromptDetector.js';
import { ErrorDetector } from '../core/ErrorDetector.js';

/**
 * SSH Protocol implementation for secure remote shell access
 *
 * Features:
 * - Connection pooling and reuse
 * - Keep-alive and health monitoring
 * - Authentication (password, key, interactive)
 * - Session persistence and recovery
 * - Command queuing and buffering
 * - Tunneling and port forwarding
 * - Error detection and recovery
 * - Performance monitoring
 */
export class SSHProtocol extends EventEmitter implements IProtocol {
  public readonly type = 'ssh';
  public readonly capabilities: ProtocolCapabilities;
  public readonly healthStatus: ProtocolHealthStatus;

  private logger: Logger;
  private sessions: Map<string, SSHSession> = new Map();
  private sshClients: Map<string, SSHClient> = new Map();
  private sshChannels: Map<string, ClientChannel> = new Map();
  private connectionPool: Map<string, PooledConnection> = new Map();
  private streamManagers: Map<string, StreamManager> = new Map();
  private outputBuffers: Map<string, ConsoleOutput[]> = new Map();
  private commandQueues: Map<string, SessionCommandQueue> = new Map();
  private commandProcessingIntervals: Map<string, NodeJS.Timeout> = new Map();
  private isInitialized: boolean = false;

  // Components
  private sshKeepAlive: SSHConnectionKeepAlive;
  private promptDetector: PromptDetector;
  private errorDetector: ErrorDetector;

  // Configuration
  private queueConfig: CommandQueueConfig;
  private maxReconnectAttempts: number = 3;
  private connectionTimeout: number = 30000;

  constructor(config?: {
    maxConcurrentSessions?: number;
    connectionTimeout?: number;
    keepAliveConfig?: Partial<KeepAliveConfig>;
    queueConfig?: Partial<CommandQueueConfig>;
  }) {
    super();
    this.logger = new Logger('SSHProtocol');

    // Configure command queue system
    this.queueConfig = {
      enabled: true,
      maxQueueSize: config?.queueConfig?.maxQueueSize || 100,
      commandTimeout: config?.queueConfig?.commandTimeout || 30000,
      acknowledgmentTimeout: config?.queueConfig?.acknowledgmentTimeout || 5000,
      retryAttempts: config?.queueConfig?.retryAttempts || 3,
      retryDelay: config?.queueConfig?.retryDelay || 1000,
      maxConcurrentCommands: config?.queueConfig?.maxConcurrentCommands || 5,
      enablePersistence: config?.queueConfig?.enablePersistence ?? true,
      enableMetrics: config?.queueConfig?.enableMetrics ?? true,
      bufferSize: config?.queueConfig?.bufferSize || 8192,
      compressionEnabled: config?.queueConfig?.compressionEnabled ?? false
    };

    this.connectionTimeout = config?.connectionTimeout || 30000;
    this.maxReconnectAttempts = 3;

    this.capabilities = {
      supportsStreaming: true,
      supportsFileTransfer: true,
      supportsX11Forwarding: true,
      supportsPortForwarding: true,
      supportsAuthentication: true,
      supportsEncryption: true,
      supportsCompression: true,
      supportsMultiplexing: true,
      supportsKeepAlive: true,
      supportsReconnection: true,
      supportsBinaryData: true,
      supportsCustomEnvironment: true,
      supportsWorkingDirectory: true,
      supportsSignals: true,
      supportsResizing: true,
      supportsPTY: true,
      maxConcurrentSessions: config?.maxConcurrentSessions || 20,
      defaultTimeout: this.connectionTimeout,
      supportedEncodings: ['utf-8', 'ascii', 'binary'],
      supportedAuthMethods: ['password', 'publickey', 'keyboard-interactive', 'agent'],
      platformSupport: {
        windows: true,
        linux: true,
        macos: true,
        freebsd: true,
      },
    };

    this.healthStatus = {
      isHealthy: true,
      lastChecked: new Date(),
      errors: [],
      warnings: [],
      metrics: {
        activeSessions: 0,
        totalSessions: 0,
        averageLatency: 0,
        successRate: 1.0,
        uptime: 0,
      },
      dependencies: {
        ssh2: {
          available: true,
          version: '1.0.0',
        },
      },
    };

    // Initialize SSH keep-alive system
    this.sshKeepAlive = new SSHConnectionKeepAlive({
      enabled: true,
      keepAliveInterval: 30000,
      keepAliveCountMax: 6,
      serverAliveInterval: 60000,
      serverAliveCountMax: 3,
      connectionTimeout: this.connectionTimeout,
      reconnectOnFailure: true,
      maxReconnectAttempts: this.maxReconnectAttempts,
      reconnectDelay: 5000,
      backoffMultiplier: 2,
      maxReconnectDelay: 60000,
      enableAdaptiveKeepAlive: true,
      enablePredictiveReconnect: true,
      connectionHealthThreshold: 70,
      ...config?.keepAliveConfig
    });

    // Initialize prompt detector
    this.promptDetector = new PromptDetector();

    // Initialize error detector
    this.errorDetector = new ErrorDetector();

    this.setupEventHandlers();
  }

  /**
   * Setup event handlers for components
   */
  private setupEventHandlers(): void {
    // SSH Keep-Alive event handlers
    this.sshKeepAlive.on('keep-alive-success', ({ connectionId, responseTime }) => {
      this.logger.debug(`SSH keep-alive success: ${connectionId} (${responseTime}ms)`);
      this.updateHealthMetrics(true, responseTime);
    });

    this.sshKeepAlive.on('keep-alive-failed', ({ connectionId, error, timestamp }) => {
      this.logger.warn(`SSH keep-alive failed: ${connectionId} - ${error}`);
      this.updateHealthMetrics(false, 0);
      this.emit('connection-degraded', { connectionId, error, timestamp });
    });

    this.sshKeepAlive.on('reconnection-started', ({ connectionId, reason }) => {
      this.logger.info(`SSH reconnection started: ${connectionId} (${reason})`);
      this.emit('reconnection-started', { connectionId, reason });
    });

    this.sshKeepAlive.on('reconnection-success', ({ connectionId, reason }) => {
      this.logger.info(`SSH reconnection successful: ${connectionId} (${reason})`);
      this.emit('reconnection-success', { connectionId, reason });
    });

    this.sshKeepAlive.on('reconnection-failed', ({ connectionId, reason, error }) => {
      this.logger.error(`SSH reconnection failed: ${connectionId} (${reason}) - ${error}`);
      this.emit('reconnection-failed', { connectionId, reason, error });
    });
  }

  async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      this.logger.info('Initializing SSH Protocol...');

      // Start SSH keep-alive system
      await this.sshKeepAlive.start();

      // Initialize prompt detector with SSH patterns
      this.initializePromptPatterns();

      // Initialize error detector with SSH patterns
      this.initializeErrorPatterns();

      this.isInitialized = true;
      this.healthStatus.isHealthy = true;
      this.healthStatus.lastChecked = new Date();

      this.logger.info('SSH Protocol initialized successfully');
      this.emit('initialized');
    } catch (error) {
      this.healthStatus.isHealthy = false;
      this.healthStatus.errors.push(`Failed to initialize: ${error}`);
      this.logger.error('Failed to initialize SSH Protocol:', error);
      throw error;
    }
  }

  async createSession(options: SessionOptions): Promise<ConsoleSession> {
    if (!this.isInitialized) {
      throw new Error('SSH Protocol not initialized');
    }

    if (!options.sshOptions) {
      throw new Error('SSH options required for SSH session');
    }

    const sessionId = uuidv4();
    this.logger.info(`Creating SSH session: ${sessionId}`);

    try {
      // Parse SSH command if provided
      let sshConfig: SSHConnectionOptions;
      if (options.command && this.isSSHCommand(options.command)) {
        sshConfig = this.parseSSHCommand(options.command);
        // Merge with provided SSH options
        sshConfig = { ...sshConfig, ...options.sshOptions };
      } else {
        sshConfig = options.sshOptions;
      }

      // Validate SSH configuration
      this.validateSSHConfig(sshConfig);

      // Check connection pool first
      const poolKey = this.getConnectionPoolKey(sshConfig.host, sshConfig.port || 22, sshConfig.username);
      let sshClient: SSHClient;
      let usePooledConnection = false;

      const pooledConnection = this.connectionPool.get(poolKey);
      if (pooledConnection && this.isConnectionHealthy(pooledConnection)) {
        this.logger.debug(`Using pooled SSH connection: ${poolKey}`);
        sshClient = pooledConnection.connection;
        usePooledConnection = true;
      } else {
        // Create new SSH connection
        this.logger.debug(`Creating new SSH connection: ${poolKey}`);
        sshClient = await this.createSSHConnection(sshConfig, sessionId);

        // Add to connection pool
        const pooledConn: PooledConnection = {
          id: poolKey,
          connection: sshClient,
          createdAt: new Date(),
          lastUsed: new Date(),
          isActive: true,
          sessionsCount: 0,
          config: sshConfig
        };
        this.connectionPool.set(poolKey, pooledConn);

        // Start monitoring the connection
        this.sshKeepAlive.monitorConnection(pooledConn, sshConfig);
      }

      // Create shell channel
      const channel = await this.createSSHChannel(sshClient, sessionId);

      // Create console session
      const session: ConsoleSession = {
        id: sessionId,
        command: options.command || '',
        args: options.args || [],
        cwd: options.cwd || '~',
        env: options.env || {},
        createdAt: new Date(),
        status: 'running',
        type: 'ssh',
        streaming: options.streaming ?? false,
        sshOptions: sshConfig,
        executionState: 'idle',
        activeCommands: new Map(),
      };

      // Create SSH session wrapper
      const sshSession: SSHSession = {
        id: sessionId,
        client: sshClient,
        channel: channel,
        created: new Date(),
        lastActivity: new Date(),
        isActive: true,
        poolKey: poolKey,
        usePooledConnection: usePooledConnection
      };

      // Store session and connection references
      this.sessions.set(sessionId, sshSession);
      this.sshClients.set(sessionId, sshClient);
      this.sshChannels.set(sessionId, channel);
      this.outputBuffers.set(sessionId, []);

      // Setup stream manager if streaming enabled
      if (options.streaming) {
        const streamManager = new StreamManager(sessionId);
        this.streamManagers.set(sessionId, streamManager);
      }

      // Setup SSH handlers
      this.setupSSHHandlers(sessionId, channel, options);

      // Initialize command queue
      this.initializeCommandQueue(sessionId);

      // Configure prompt detection
      this.configurePromptDetection(sessionId, options);

      // Update pool usage
      if (usePooledConnection && pooledConnection) {
        pooledConnection.sessionsCount++;
        pooledConnection.lastUsed = new Date();
      }

      // Update metrics
      this.healthStatus.metrics.activeSessions++;
      this.healthStatus.metrics.totalSessions++;

      this.logger.info(`SSH session created successfully: ${sessionId}`);
      this.emit('sessionCreated', session);

      return session;

    } catch (error) {
      this.logger.error(`Failed to create SSH session ${sessionId}:`, error);

      // Clean up on failure
      await this.cleanupSession(sessionId, false);

      // Update health status
      this.healthStatus.errors.push(`Session creation failed: ${error}`);
      this.updateHealthMetrics(false, 0);

      throw error;
    }
  }

  async executeCommand(sessionId: string, command: string, args?: string[]): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new Error(`SSH session not found: ${sessionId}`);
    }

    const fullCommand = args ? `${command} ${args.join(' ')}` : command;
    this.logger.debug(`Executing SSH command: ${sessionId} - ${fullCommand}`);

    try {
      // Add command to queue to prevent command overlap
      await this.addCommandToQueue(sessionId, fullCommand);

      session.lastActivity = new Date();
      this.emit('commandExecuted', { sessionId, command, args, timestamp: new Date() });
    } catch (error) {
      this.logger.error(`Failed to execute command in session ${sessionId}:`, error);
      throw error;
    }
  }

  async sendInput(sessionId: string, input: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new Error(`SSH session not found: ${sessionId}`);
    }

    const channel = this.sshChannels.get(sessionId);
    if (!channel) {
      throw new Error(`SSH channel not found: ${sessionId}`);
    }

    try {
      // Use command queue for SSH sessions to prevent command concatenation
      await this.addCommandToQueue(sessionId, input);

      session.lastActivity = new Date();
      this.emit('inputSent', { sessionId, input, timestamp: new Date() });
    } catch (error) {
      this.logger.error(`Failed to send input to session ${sessionId}:`, error);
      throw error;
    }
  }

  async getOutput(sessionId: string, since?: Date): Promise<string> {
    const outputs = this.outputBuffers.get(sessionId);
    if (!outputs) {
      return '';
    }

    let filteredOutputs = outputs;
    if (since) {
      filteredOutputs = outputs.filter(output => output.timestamp >= since);
    }

    return filteredOutputs.map(output => output.text).join('');
  }

  async closeSession(sessionId: string): Promise<void> {
    this.logger.info(`Closing SSH session: ${sessionId}`);

    try {
      await this.cleanupSession(sessionId, true);
      this.emit('sessionClosed', sessionId);
    } catch (error) {
      this.logger.error(`Error closing SSH session ${sessionId}:`, error);
      throw error;
    }
  }

  async getHealthStatus(): Promise<ProtocolHealthStatus> {
    this.healthStatus.lastChecked = new Date();
    this.healthStatus.metrics.activeSessions = this.sessions.size;

    // Update health status based on connections
    const unhealthyConnections = Array.from(this.connectionPool.values())
      .filter(conn => !this.isConnectionHealthy(conn));

    if (unhealthyConnections.length > 0) {
      this.healthStatus.warnings.push(`${unhealthyConnections.length} unhealthy connections detected`);
    }

    // Get keep-alive statistics
    const keepAliveStats = this.sshKeepAlive.getKeepAliveStatistics();
    this.healthStatus.metrics.successRate = keepAliveStats.totalKeepAlives > 0
      ? keepAliveStats.successfulKeepAlives / keepAliveStats.totalKeepAlives
      : 1.0;
    this.healthStatus.metrics.averageLatency = keepAliveStats.averageResponseTime;

    return { ...this.healthStatus };
  }

  async dispose(): Promise<void> {
    this.logger.info('Disposing SSH Protocol...');

    try {
      // Stop all command processing intervals
      for (const [sessionId, interval] of this.commandProcessingIntervals) {
        clearInterval(interval);
      }
      this.commandProcessingIntervals.clear();

      // Close all sessions
      const sessionIds = Array.from(this.sessions.keys());
      await Promise.all(sessionIds.map(id => this.cleanupSession(id, true)));

      // Stop SSH keep-alive system
      await this.sshKeepAlive.stop();

      // Clear all data structures
      this.sessions.clear();
      this.sshClients.clear();
      this.sshChannels.clear();
      this.connectionPool.clear();
      this.streamManagers.clear();
      this.outputBuffers.clear();
      this.commandQueues.clear();

      this.removeAllListeners();
      this.isInitialized = false;

      this.logger.info('SSH Protocol disposed successfully');
    } catch (error) {
      this.logger.error('Error disposing SSH Protocol:', error);
      throw error;
    }
  }

  // ================================
  // SSH-specific implementation methods
  // ================================

  /**
   * Check if a command string is an SSH command
   */
  private isSSHCommand(command: string): boolean {
    const sshPattern = /^ssh\s+/i;
    return sshPattern.test(command.trim());
  }

  /**
   * Parse SSH command into connection options
   */
  private parseSSHCommand(command: string): SSHConnectionOptions {
    const parts = command.trim().split(/\s+/);
    const result: SSHConnectionOptions = {
      host: '',
      port: 22,
      username: undefined,
      password: undefined,
      privateKeyPath: undefined
    };

    // Find the target (user@host or just host)
    let targetIndex = -1;
    for (let i = 1; i < parts.length; i++) {
      if (!parts[i].startsWith('-') && parts[i-1] !== '-p' && parts[i-1] !== '-i') {
        targetIndex = i;
        break;
      }
    }

    if (targetIndex === -1) {
      throw new Error('Invalid SSH command: no target specified');
    }

    const target = parts[targetIndex];
    if (target.includes('@')) {
      const [user, host] = target.split('@');
      result.username = user;
      result.host = host;
    } else {
      result.host = target;
    }

    // Parse options
    for (let i = 1; i < parts.length; i++) {
      const part = parts[i];

      if (part === '-p' && i + 1 < parts.length) {
        result.port = parseInt(parts[i + 1], 10);
        i++; // Skip next part
      } else if (part === '-i' && i + 1 < parts.length) {
        result.privateKeyPath = parts[i + 1];
        i++; // Skip next part
      } else if (part === '-l' && i + 1 < parts.length) {
        result.username = parts[i + 1];
        i++; // Skip next part
      }
    }

    return result;
  }

  /**
   * Validate SSH configuration
   */
  private validateSSHConfig(config: SSHConnectionOptions): void {
    if (!config.host) {
      throw new Error('SSH host is required');
    }

    if (config.port && (config.port < 1 || config.port > 65535)) {
      throw new Error('SSH port must be between 1 and 65535');
    }

    if (!config.username && !config.password && !config.privateKey && !config.privateKeyPath) {
      // Use default username from environment
      config.username = process.env.USER || process.env.USERNAME || 'root';
    }
  }

  /**
   * Get connection pool key
   */
  private getConnectionPoolKey(host: string, port: number, user?: string): string {
    return `${user || 'default'}@${host}:${port}`;
  }

  /**
   * Check if pooled connection is healthy
   */
  private isConnectionHealthy(connection: PooledConnection): boolean {
    if (!connection.isActive) {
      return false;
    }

    const client = connection.connection as SSHClient;
    // Check if connection is still open
    return (client as any)._sock?.readyState === 'open';
  }

  /**
   * Create SSH connection
   */
  private async createSSHConnection(sshConfig: SSHConnectionOptions, sessionId: string): Promise<SSHClient> {
    const sshClient = new SSHClient();

    const connectConfig: ConnectConfig = {
      host: sshConfig.host,
      port: sshConfig.port || 22,
      username: sshConfig.username || process.env.USER || process.env.USERNAME || 'root',
      readyTimeout: this.connectionTimeout,
      keepaliveInterval: 30000,
      keepaliveCountMax: 3
    };

    // Configure authentication
    if (sshConfig.password) {
      connectConfig.password = sshConfig.password;
    } else if (sshConfig.privateKey) {
      connectConfig.privateKey = sshConfig.privateKey;
    } else if (sshConfig.privateKeyPath) {
      try {
        connectConfig.privateKey = readFileSync(sshConfig.privateKeyPath);
      } catch (error) {
        throw new Error(`Failed to read private key: ${sshConfig.privateKeyPath} - ${error}`);
      }
    }

    if (sshConfig.passphrase) {
      connectConfig.passphrase = sshConfig.passphrase;
    }

    // Additional SSH options
    if (sshConfig.algorithms) {
      connectConfig.algorithms = sshConfig.algorithms;
    }

    if (sshConfig.hostVerifier) {
      connectConfig.hostVerifier = sshConfig.hostVerifier;
    }

    await this.connectSSH(sshClient, connectConfig, sessionId);
    return sshClient;
  }

  /**
   * Connect SSH client with retry logic
   */
  private async connectSSH(client: SSHClient, config: ConnectConfig, sessionId: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error(`SSH connection timeout after ${this.connectionTimeout}ms`));
      }, this.connectionTimeout);

      client.on('ready', () => {
        clearTimeout(timeout);
        this.logger.debug(`SSH connection established: ${config.host}:${config.port}`);
        resolve();
      });

      client.on('error', (error) => {
        clearTimeout(timeout);
        this.logger.error(`SSH connection error: ${error.message}`);
        reject(error);
      });

      client.on('close', () => {
        this.logger.debug(`SSH connection closed: ${config.host}:${config.port}`);
        this.handleConnectionClose(client, sessionId);
      });

      try {
        client.connect(config);
      } catch (error) {
        clearTimeout(timeout);
        reject(error);
      }
    });
  }

  /**
   * Create SSH shell channel
   */
  private async createSSHChannel(client: SSHClient, sessionId: string): Promise<ClientChannel> {
    return new Promise((resolve, reject) => {
      client.shell((error, channel) => {
        if (error) {
          this.logger.error(`Failed to create SSH shell channel: ${error.message}`);
          reject(error);
          return;
        }

        // Configure PTY
        channel.setWindow(120, 40, 960, 480);

        this.logger.debug(`SSH shell channel created for session: ${sessionId}`);
        resolve(channel);
      });
    });
  }

  /**
   * Setup SSH channel handlers
   */
  private setupSSHHandlers(sessionId: string, channel: ClientChannel, options: SessionOptions): void {
    const streamManager = this.streamManagers.get(sessionId);

    // Handle data from SSH channel
    channel.on('data', (data: Buffer) => {
      this.handleChannelData(sessionId, data, streamManager);
    });

    // Handle channel close
    channel.on('close', () => {
      this.logger.debug(`SSH channel closed for session: ${sessionId}`);
      this.handleChannelClose(sessionId);
    });

    // Handle channel errors
    channel.on('error', (error: Error) => {
      this.logger.error(`SSH channel error for session ${sessionId}:`, error);
      this.handleChannelError(sessionId, error);
    });

    // Setup stderr handling
    channel.stderr.on('data', (data: Buffer) => {
      this.handleChannelData(sessionId, data, streamManager, true);
    });
  }

  /**
   * Handle data from SSH channel
   */
  private handleChannelData(sessionId: string, data: Buffer, streamManager?: StreamManager, isStderr: boolean = false): void {
    const text = data.toString();
    const cleanText = stripAnsi(text);

    // Add to output buffer
    const output: ConsoleOutput = {
      text: cleanText,
      timestamp: new Date(),
      source: isStderr ? 'stderr' : 'stdout',
      sessionId: sessionId
    };

    const buffer = this.outputBuffers.get(sessionId);
    if (buffer) {
      buffer.push(output);

      // Limit buffer size
      if (buffer.length > 10000) {
        buffer.splice(0, buffer.length - 10000);
      }
    }

    // Stream management
    if (streamManager) {
      streamManager.addOutput(output);
    }

    // Prompt detection
    const promptResult = this.promptDetector.addOutput(sessionId, cleanText);
    if (promptResult?.detected) {
      this.logger.debug(`Prompt detected in SSH session ${sessionId}`, {
        pattern: promptResult.pattern?.name,
        confidence: promptResult.confidence
      });
      this.emit('promptDetected', { sessionId, promptResult });
    }

    // Error detection
    const errors = this.errorDetector.detectErrors(cleanText);
    if (errors.length > 0) {
      this.logger.warn(`Errors detected in SSH session ${sessionId}:`, errors);
      this.emit('errorsDetected', { sessionId, errors });
    }

    // Update session activity
    const session = this.sessions.get(sessionId);
    if (session) {
      session.lastActivity = new Date();
    }

    // Emit data event
    this.emit('data', { sessionId, data: cleanText, isStderr, timestamp: new Date() });
  }

  /**
   * Handle SSH channel close
   */
  private handleChannelClose(sessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.isActive = false;
    }

    this.emit('channelClosed', { sessionId, timestamp: new Date() });
  }

  /**
   * Handle SSH channel error
   */
  private handleChannelError(sessionId: string, error: Error): void {
    this.logger.error(`SSH channel error for session ${sessionId}:`, error);

    const session = this.sessions.get(sessionId);
    if (session) {
      session.isActive = false;
    }

    this.healthStatus.errors.push(`Channel error: ${error.message}`);
    this.emit('channelError', { sessionId, error: error.message, timestamp: new Date() });
  }

  /**
   * Handle SSH connection close
   */
  private handleConnectionClose(client: SSHClient, sessionId: string): void {
    this.logger.warn(`SSH connection closed unexpectedly for session: ${sessionId}`);

    // Find and mark pooled connection as inactive
    for (const [poolKey, pooledConn] of this.connectionPool) {
      if (pooledConn.connection === client) {
        pooledConn.isActive = false;
        this.logger.debug(`Marked pooled connection as inactive: ${poolKey}`);
        break;
      }
    }

    this.emit('connectionClosed', { sessionId, timestamp: new Date() });
  }

  /**
   * Initialize command queue for session
   */
  private initializeCommandQueue(sessionId: string): void {
    if (!this.commandQueues.has(sessionId)) {
      const queue: SessionCommandQueue = {
        sessionId,
        commands: [],
        isProcessing: false,
        lastCommandTime: 0,
        acknowledgmentTimeout: null,
        config: { ...this.queueConfig }
      };

      this.commandQueues.set(sessionId, queue);

      // Start command processing interval
      const interval = setInterval(() => {
        this.processCommandQueue(sessionId);
      }, 100); // Check every 100ms

      this.commandProcessingIntervals.set(sessionId, interval);
      this.logger.debug(`Command queue initialized for session: ${sessionId}`);
    }
  }

  /**
   * Add command to queue
   */
  private async addCommandToQueue(sessionId: string, input: string): Promise<void> {
    this.initializeCommandQueue(sessionId);
    const queue = this.commandQueues.get(sessionId)!;

    if (queue.commands.length >= this.queueConfig.maxQueueSize) {
      throw new Error(`Command queue full for session ${sessionId} (max: ${this.queueConfig.maxQueueSize})`);
    }

    return new Promise<void>((resolve, reject) => {
      const command: QueuedCommand = {
        id: uuidv4(),
        sessionId,
        input,
        timestamp: new Date(),
        resolve,
        reject
      };

      queue.commands.push(command);
      this.logger.debug(`Command queued for session ${sessionId}: ${input.substring(0, 50)}`);
    });
  }

  /**
   * Process command queue
   */
  private async processCommandQueue(sessionId: string): Promise<void> {
    const queue = this.commandQueues.get(sessionId);
    const channel = this.sshChannels.get(sessionId);

    if (!queue || !channel || queue.isProcessing || queue.commands.length === 0) {
      return;
    }

    queue.isProcessing = true;

    try {
      const command = queue.commands[0];
      const now = Date.now();

      // Check if enough time has passed since last command
      if (now - queue.lastCommandTime < 50) {
        queue.isProcessing = false;
        return;
      }

      // Send command
      channel.write(command.input);
      if (!command.input.endsWith('\n')) {
        channel.write('\n');
      }

      queue.lastCommandTime = now;

      // Set acknowledgment timeout
      queue.acknowledgmentTimeout = setTimeout(() => {
        if (command.reject) {
          command.reject(new Error(`Command acknowledgment timeout: ${command.input}`));
        }
        queue.commands.shift(); // Remove timed out command
        queue.isProcessing = false;
      }, this.queueConfig.acknowledgmentTimeout);

      // For now, assume immediate success (real implementation would wait for prompt)
      setTimeout(() => {
        if (queue.acknowledgmentTimeout) {
          clearTimeout(queue.acknowledgmentTimeout);
          queue.acknowledgmentTimeout = null;
        }

        if (command.resolve) {
          command.resolve();
        }

        queue.commands.shift();
        queue.isProcessing = false;
      }, 100);

    } catch (error) {
      const command = queue.commands.shift();
      if (command?.reject) {
        command.reject(error);
      }
      queue.isProcessing = false;
      this.logger.error(`Error processing command queue for session ${sessionId}:`, error);
    }
  }

  /**
   * Clean up session resources
   */
  private async cleanupSession(sessionId: string, graceful: boolean): Promise<void> {
    this.logger.debug(`Cleaning up SSH session: ${sessionId} (graceful: ${graceful})`);

    // Stop command processing
    const interval = this.commandProcessingIntervals.get(sessionId);
    if (interval) {
      clearInterval(interval);
      this.commandProcessingIntervals.delete(sessionId);
    }

    // Clear command queue
    const queue = this.commandQueues.get(sessionId);
    if (queue) {
      if (queue.acknowledgmentTimeout) {
        clearTimeout(queue.acknowledgmentTimeout);
      }
      // Reject pending commands
      queue.commands.forEach(cmd => {
        if (cmd.reject) {
          cmd.reject(new Error('Session closed'));
        }
      });
      this.commandQueues.delete(sessionId);
    }

    // Close SSH channel
    const channel = this.sshChannels.get(sessionId);
    if (channel) {
      if (graceful) {
        channel.end();
      } else {
        channel.destroy();
      }
      this.sshChannels.delete(sessionId);
    }

    // Handle SSH client
    const client = this.sshClients.get(sessionId);
    const session = this.sessions.get(sessionId);

    if (client && session) {
      if (session.usePooledConnection) {
        // Don't close pooled connections, just decrement usage
        const pooledConn = this.connectionPool.get(session.poolKey!);
        if (pooledConn) {
          pooledConn.sessionsCount = Math.max(0, pooledConn.sessionsCount - 1);
          this.logger.debug(`Decremented pooled connection usage: ${session.poolKey} (${pooledConn.sessionsCount})`);
        }
      } else {
        // Close non-pooled connection
        if (graceful) {
          client.end();
        } else {
          client.destroy();
        }

        // Remove from pool if it exists
        if (session.poolKey) {
          this.connectionPool.delete(session.poolKey);
          this.sshKeepAlive.stopMonitoring(session.poolKey);
        }
      }

      this.sshClients.delete(sessionId);
    }

    // Clean up other resources
    this.sessions.delete(sessionId);
    this.streamManagers.delete(sessionId);
    this.outputBuffers.delete(sessionId);

    // Update metrics
    this.healthStatus.metrics.activeSessions = Math.max(0, this.healthStatus.metrics.activeSessions - 1);

    this.logger.debug(`SSH session cleanup completed: ${sessionId}`);
  }

  /**
   * Initialize prompt patterns for SSH
   */
  private initializePromptPatterns(): void {
    // Common SSH prompt patterns
    const sshPatterns = [
      { name: 'bash', pattern: /[\w\-\.]+[@\s]+[\w\-\.]+[:\s]*[\w\-\.\/~]*\$\s*$/, confidence: 0.9 },
      { name: 'zsh', pattern: /[\w\-\.]+[@\s]+[\w\-\.]+[:\s]*[\w\-\.\/~]*%\s*$/, confidence: 0.9 },
      { name: 'fish', pattern: /[\w\-\.]+[@\s]+[\w\-\.]+[:\s]*[\w\-\.\/~]*>\s*$/, confidence: 0.8 },
      { name: 'root', pattern: /#\s*$/, confidence: 0.7 },
      { name: 'generic', pattern: /[\$%>#]\s*$/, confidence: 0.5 }
    ];

    sshPatterns.forEach(pattern => {
      this.promptDetector.addPattern(pattern.name, pattern.pattern, pattern.confidence);
    });
  }

  /**
   * Initialize error patterns for SSH
   */
  private initializeErrorPatterns(): void {
    const sshErrorPatterns: ExtendedErrorPattern[] = [
      {
        name: 'ssh_connection_refused',
        pattern: /connection refused/i,
        type: 'error',
        severity: 'high',
        category: 'connection',
        recoverable: true,
        description: 'SSH connection was refused by the target host'
      },
      {
        name: 'ssh_permission_denied',
        pattern: /permission denied/i,
        type: 'error',
        severity: 'critical',
        category: 'authentication',
        recoverable: false,
        description: 'SSH authentication failed'
      },
      {
        name: 'ssh_host_key_verification_failed',
        pattern: /host key verification failed/i,
        type: 'error',
        severity: 'high',
        category: 'security',
        recoverable: true,
        description: 'SSH host key verification failed'
      },
      {
        name: 'ssh_connection_timeout',
        pattern: /connection.*timeout/i,
        type: 'warning',
        severity: 'medium',
        category: 'network',
        recoverable: true,
        description: 'SSH connection timed out'
      }
    ];

    sshErrorPatterns.forEach(pattern => {
      this.errorDetector.addPattern(pattern);
    });
  }

  /**
   * Configure prompt detection for session
   */
  private configurePromptDetection(sessionId: string, options: SessionOptions): void {
    // Configure session-specific prompt detection if needed
    // TODO: Add promptPattern to SSHConnectionOptions interface
    // if (options.sshOptions?.promptPattern) {
    //   this.promptDetector.addPattern(
    //     `${sessionId}_custom`,
    //     new RegExp(options.sshOptions.promptPattern),
    //     0.95
    //   );
    // }
  }

  /**
   * Update health metrics
   */
  private updateHealthMetrics(success: boolean, responseTime: number): void {
    const metrics = this.healthStatus.metrics;

    if (success) {
      // Update average latency
      if (metrics.averageLatency === 0) {
        metrics.averageLatency = responseTime;
      } else {
        metrics.averageLatency = (metrics.averageLatency + responseTime) / 2;
      }
    }

    // Update overall health
    const keepAliveStats = this.sshKeepAlive.getKeepAliveStatistics();
    this.healthStatus.isHealthy = keepAliveStats.isRunning &&
                                  this.healthStatus.errors.length === 0 &&
                                  keepAliveStats.successfulKeepAlives > 0;
  }

  // ================================
  // Public API methods
  // ================================

  /**
   * Get SSH connection statistics
   */
  getConnectionStats(): {
    activeSessions: number;
    pooledConnections: number;
    healthyConnections: number;
    totalSessions: number;
    keepAliveStats: any;
  } {
    const pooledConnections = Array.from(this.connectionPool.values());
    const healthyConnections = pooledConnections.filter(conn => this.isConnectionHealthy(conn));

    return {
      activeSessions: this.sessions.size,
      pooledConnections: pooledConnections.length,
      healthyConnections: healthyConnections.length,
      totalSessions: this.healthStatus.metrics.totalSessions,
      keepAliveStats: this.sshKeepAlive.getKeepAliveStatistics()
    };
  }

  /**
   * Force connection health check
   */
  async checkConnectionHealth(sessionId?: string): Promise<Record<string, boolean>> {
    const results: Record<string, boolean> = {};

    if (sessionId) {
      const session = this.sessions.get(sessionId);
      if (session && session.poolKey) {
        const pooledConn = this.connectionPool.get(session.poolKey);
        results[sessionId] = pooledConn ? this.isConnectionHealthy(pooledConn) : false;
      }
    } else {
      for (const [sessionId, session] of this.sessions) {
        if (session.poolKey) {
          const pooledConn = this.connectionPool.get(session.poolKey);
          results[sessionId] = pooledConn ? this.isConnectionHealthy(pooledConn) : false;
        }
      }
    }

    return results;
  }

  /**
   * Get session information
   */
  getSessionInfo(sessionId: string): SSHSession | undefined {
    return this.sessions.get(sessionId);
  }

  /**
   * List all active sessions
   */
  listActiveSessions(): SSHSession[] {
    return Array.from(this.sessions.values()).filter(session => session.isActive);
  }
}

interface SSHSession {
  id: string;
  client: SSHClient;
  channel: ClientChannel;
  created: Date;
  lastActivity: Date;
  isActive: boolean;
  poolKey?: string;
  usePooledConnection: boolean;
}